[{"content":"A few days ago, I discovered an old project on an even older HDD. I suspect that this was my first time tinkering with emulators, and also my first time trying out Python 3. It turned out quite alright.\nThe project is an interpreter for a CHIP-8, an assembler-like language developed in the 70s. Implementations of CHIP-8 VMs like this one are often called emulators, although this is strictly speaking incorrect, as the CHIP-8 is not a real hardware platform. Having just 35 opcodes, writing a toy CHIP-8 interpreter takes rather low commitment aside from actually learning how an emulator/interpreter works and trying out Python 3.\nThis implementation is from around 2012 I suspect, but as of yet unpublished. It is poorly tested and probably ridden with bugs, and the perfectionist inside prevented me from ever just putting it out there. The actual result however is rather cool, the ncurses TUI sells the retro look and feel very well, as the following \u0026ldquo;screenshot\u0026rdquo; of \u0026ldquo;Breakout!\u0026rdquo; can prove:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ┌────────────────────────────────────────────────────────────────┬────────────────────────────────┐ │█ █ █ █ █ ████ █ │ 0x025A: sprite VC,VD,0x1 │ │ █ █ ██ │ 0x025C: mvi 0x30E │ │ █ █ █ │ 0x025E: sprite V6,V7,0x1 │ │ █ █ █ │ 0x0260: add V6,V8 │ │ ████ ███│ 0x0262: add V7,V9 │ │ │ 0x0264: mov V0,63 │ │███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ │ 0x0266: and V6,V0 │ │ │ 0x0268: mov V1,31 │ │███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ │ 0x026A: and V7,V1 │ │ │ 0x026C: skne V7,31 │ │███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ │ │ │ │ 0x0270: skne V6,0 │ │███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ │ │ │ │ 0x0274: skne V6,63 │ │███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ │ │ │ │ 0x0278: skne V7,0 │ │███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ │ │ │ │ 0x027C: sprite V6,V7,0x1 │ │ │ 0x027E: skeq VF,1 │ │ █ │ 0x0280: jmp 0x2AA │ │ │ │ │ ├────────────────────────────────┤ │ │ PC: 0x02AA │ │ │ I: 0x030E SP: 0x0000 │ │ │ V0: 0x003F V8: 0x0001 │ │ │ V1: 0x001F V9: 0x0001 │ │ │ V2: 0x0001 VA: 0x0040 │ │ │ V3: 0x003C VB: 0x0012 │ │ │ V4: 0x0000 VC: 0x0020 │ │ │ V5: 0x0001 VD: 0x001F │ │ │ V6: 0x001C VE: 0x0005 │ │ ██████ │ V7: 0x0013 VF: 0x0000 │ └────────────────────────────────────────────────────────────────┴────────────────────────────────┘ The game window itself is on the left hand side, while the smaller side panes on the right allow a peek into interpreter internals: The upper portion shows the current memory location of the execution flow, as well as a limited view of its previous locations. Skips and jumps are visualized by empty lines. The lower portion shows the interpeters full internal state, with all relevant registers and fields.\nAn Incomplete Intro to Processors and Microcontrollers #Processors generally use commands called opcodes to manipulate the system\u0026rsquo;s memory and its peripherals. To this end, opcodes are read from memory locations specified by the program counter (PC), which is incremented after each processed instruction. This behaviour can be seen in above screenshot, where the upper right pane shows memory locations and opcodes, which have been decoded from their binary formats to their matching mnemonic.\nOften, these instructions are about arithmetics using either two registers or a single register and a constant. Other instructions manipulate the PC, thus jumping the execution to another part of the program contained in the memory. These jumps can be conditional and with or without fixed return addresses. Additionally, even simple processors implement timers and interrupts, among a plethora of other instructions.\nInstructions of CHIP-8 #As stated above, the implementation needs just 35 opcodes, which are mapped using a simple Dict:\n1 2 3 4 5 6 7 8 op_map = { 0x00e0: (\u0026#34;cls\u0026#34;, clear_screen), # 0x00e0 cls 0x00ee: (\u0026#34;rts\u0026#34;, return_from_subroutine), # 0x00ee rts 0x1000: (\u0026#34;jmp NNN\u0026#34;, jump), # 0x1NNN jmp NNN ... 0x8004: (\u0026#34;add VX,VY\u0026#34;, add_reg), # 0x8XY4 add VX,VY 0x8005: (\u0026#34;sub VX,VY\u0026#34;, sub_reg), # 0x8XY5 sub VX,VY ... Decoding an instruction works by blanking the irrelevant nibbles of an opcode. The opcode for adding constants to a register for instance is 0x7XRR, its mnemonic add VX,RR. The nibble marked as X in the hexadecimal code corresponds to one of the 16 general purpose registers (named V0 to V15), while the constant itself is encoded in the byte marked with R. An add instruction is thus decoded by taking the raw memory value and masking it with a binary AND 0xf000, effectively hiding all \u0026ldquo;instruction arguments\u0026rdquo; while doing the lookup in above Dict.\nCreating an Emulator/Interpreter #This very simple CHIP-8 interpreter is basically a loop which decodes instructions and executes them on an object which keeps the state. Most interpreters are obviously much more complex than that, but work on the same principle.\nEach time an instruction is parsed, the function matching the instruction is called with the correct parameters and the UI is updated to include the latest internals and (possibly, depending on the instruction) update the drawn screen.\nFor instance, adding a constant to an existing register value is done using the following function:\n1 2 3 4 def add_const(self): # 0x7XRR add VX,RR result = self.v[(self.opcode \u0026amp; 0x0f00) \u0026gt;\u0026gt; 8] + self.opcode \u0026amp; 0x00ff self.v[(self.opcode \u0026amp; 0x0f00) \u0026gt;\u0026gt; 8] = result \u0026amp; 0xffff return \u0026#34;add V{:X},{}\u0026#34;.format((self.opcode \u0026amp; 0x0f00) \u0026gt;\u0026gt; 8, self.opcode \u0026amp; 0x00ff) In Line 2, (self.opcode \u0026amp; 0x0f00) \u0026gt;\u0026gt; 8 extracts the nibble corresponding to the register number, while self.v[...] accesses its contents. The same is done for the opcode byte representing the constant. Both values are summed and stored in a result variable. Line 3 writes the result back into the correct register. As Python supports more than 4 bytes of integers, the result is clipped using \u0026amp; 0xffff. As per CHIP-8 documentation, nothing is done with possible overflow bits in this instruction. The return statement passes a fully decoded representation of the binary opcode back to the main loop, which will display it in the TUI\u0026rsquo;s side pane.\nThe Screen #CHIP-8 also has a very simple screen. There are very few monochrome pixels which are simply toggled on or off, with no color value. The TUI does this using the following function which adds or removes a coordinate tuple from a set, which gets drawn after an instruction has finished toggling pixels. The implementation with a set is very simple and stable. There is no need to arrange the pixels on a plane using arrays, as all instructions operate in coordinates anyways.\n1 2 def toggle_pixel(self, x, y): self.screen_contents = self.screen_contents ^ {(x, y)} The most common way to draw on the screen is the sprite instruction. This instruction takes a position (x, y) as well as a height n and toggles pixels according to the memory location specified in the I register. It starts at (x, y), moves 7 pixels to the right and starts a new line. This is repeated at most n times, toggling pixels in an 8 times n area. A pixel is only toggled when the memory content at the location from I is 1. The memory content 0xF0, 0x90, 0xF0, 0x90, 0x90 would yield the following view on a formerly empty screen (left) with said memory content repeated on the right hand side.\n1 2 3 4 5 6 7 ┌────────┬────────┐ |████ |11110000| |█ █ |10010000| |████ |11110000| |█ █ |10010000| |█ █ |10010000| └────────┴────────┘ Timers, Sound and Peripherals #Even a basic interpeter such as CHIP-8 needs some additional work. I mentioned timers before, which have to run at the correct speed and need to be set from some instructions. This implementations does this by counting off 5 cycles, which in turn are rate limited at 300Hz, resulting in the proper 60Hz timers. One of these timers triggers a beep tone, which is needs to be produced by the interpeter.\nInput is the other key peripheral that any CHIP-8 interpreter needs to implement. Certain instructions can request key inputs and the interpeter needs to pass that information into the internal state.\nWrapping up #I remember writing this emulator as a fun project, but also as an educational one. I think I haven\u0026rsquo;t used Python 2 in a fresh project since, and recapping how interpreters or processors work didn\u0026rsquo;t hurt either. The other takeaway from this \u0026ndash; ten years later \u0026ndash; is that one shouldn\u0026rsquo;t be afraid to publish imperfect code, lest it gets buried in an old backup.\nAgain, you can find the code here\n","date":"27 April 2022","permalink":"/posts/chip8/","section":"Posts","summary":"A few days ago, I discovered an old project on an even older HDD. I suspect that this was my first time tinkering with emulators, and also my first time trying out Python 3. It turned out quite alright.","title":"A toy CHIP-8 Interpreter"},{"content":"","date":null,"permalink":"/","section":"danieln.de","summary":"","title":"danieln.de"},{"content":"","date":null,"permalink":"/tags/interpreter/","section":"Tags","summary":"","title":"Interpreter"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/project/","section":"Tags","summary":"","title":"Project"},{"content":"","date":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/hardware/","section":"Tags","summary":"","title":"Hardware"},{"content":"","date":null,"permalink":"/tags/keyboard/","section":"Tags","summary":"","title":"Keyboard"},{"content":"I recently decided to get a new keyboard, as I have been typing on my notebook until now. I\u0026rsquo;ve aways been interested in mechanical keyboards, but haven\u0026rsquo;t been willing to break the bank for parts I\u0026rsquo;d even solder myself. Being more of a software guy, I started out by looking at firmware, specifically QMK.\nFinding a keyboard #I browsed the list of supported hardware specifically to find a complete build that I can upgrade break open and flash with QMK, i.e. a regular consumer keyboard that uses an Arduino Pro internally.\nI decided on a Durgod K320 with Cherry Brown switches. It comes with an US ANSI layout and comes apart without too much of a fuss, although very solidly built. The initial flash was easy enough, and from then on a magic key combination is available to enter flashing mode.\nThe good stuff #Coding your own layouts into your firmware has some advantages. I\u0026rsquo;ve done the usual things of fixing annoying LEDs and removing unwanted functionality, but here are some of the more fun ones.\nMouse Mode #QMK supports mouse keys, which I toggle using two different actions:\nLT(_MS, KC_ESC) on my escape key, which makes it act as escape when hit, but enables mouse mode when held down TT(_MS) on my so-called context menu button (left of right control), which enables mouse mode on a double tap (to prevent accidental presses) Mouse mode itself is an assemblage of different key maps on an otherwise blank layer. It basically maps WASD, HJKL and the arrow keys to mouse movement, with somewhat ergonomic mouse button locations when using either of these options. You can see the full layer here.\nUmlauts #I\u0026rsquo;ve always had Caps remapped to Escape in software, but using QMK I can repeat above trick of holding down this new escape key to access a Umlaut layer. Umlauts are fancy vowels with two dots, i.e. ä, ü, and ö, that are equivalent to ae, oe, and oe respectively1. Using this, I could easily type them as Caps plus the base vowel. However, I still find myself using the international alt key mappings that generally come with Linux, i.e. right Alt plus Q (ä), plus Y (ü) and plus P (ö).\nAdditional extra keys #I\u0026rsquo;ve always liked having my window manager act on keys such as XF86VolumeUp. Laptops often come with a whole load of extra ones on their keys upwards of F7. At first I was stumped on how to map them, but using some rather arcane tables and some trial and error, I\u0026rsquo;ve found the following ones to work reliably. I can just define those keys to emit F20 for instance, and I get to use the valuable XF86AudioMicMute in my window manager. As you can see on any product image, Durgod printed audio mute, lower and raise volume on F5 to F7. F8 however has been neglected and remains without a print, but it is predestined to be mapped to F20.\nKey Key Code Name in graphical environment F13 191 XF86Tools F14 192 XF86Launch5 F15 193 XF86Launch6 F16 194 XF86Launch7 F17 195 XF86Launch8 F18 196 XF86Launch9 F19 197 N/A F20 198 XF86AudioMicMute F21 199 XF86TouchpadToggle F22 200 XF86TouchpadOn F23 201 XF86TouchpadOff Germans love them, and even my name got one.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"8 March 2021","permalink":"/posts/qmk-keymaps/","section":"Posts","summary":"I recently decided to get a new keyboard, as I have been typing on my notebook until now. I\u0026rsquo;ve aways been interested in mechanical keyboards, but haven\u0026rsquo;t been willing to break the bank for parts I\u0026rsquo;d even solder myself.","title":"QMK keymaps and custom keys"},{"content":"","date":null,"permalink":"/tags/monitoring/","section":"Tags","summary":"","title":"Monitoring"},{"content":"","date":null,"permalink":"/tags/prometheus/","section":"Tags","summary":"","title":"Prometheus"},{"content":"An apparently little used feature in Prometheus is the ability to create so-called consoles or console templates. Even though Prometheus ships some example consoles, this type of interface seems to be rarely used in practice. This is probably due to the reason that Grafana provides an excellent and polished interface for all visialization needs, while Prometheus' builtin web interface covers most administrative tasks and works well in all gimme-raw-metrics-right-quick-style scenarios.\nI\u0026rsquo;ve however found the flexibility the consoles interface offers working well for specialized views into your data. In my opinion, console templates and especially the dashboard-style alternatives shipped by Prometheus are not an adequate Grafana replacement. However, creating custom console templates is entirely possible and offers nearly infinite possibilities.\nCommand Line Interfaces with curl #One application of consoles is the ability to create interfaces intended for curl instead of a regular browser. This is a well-known concept, there is for example the popular and curl-enabled wttr.in. Applying this concept to Prometheus consoles, curl \u0026quot;http://hostname:9090/consoles/show_int?hostname=fra-decix-1\u0026quot; can yield this:\nThe code required to make this work is the Golang template at the end of this paragraph. These templates can get quite messy and tend to contain some amount of boilerplate code. The magic happens in the highlighted lines, which take a HTTP GET param and use that to build Prometheus queries, which in turn is being iterated over from line 20 on. This example relies on all three series being returned in the same order, but one can easily adapt this to look up corresponding values in case the stored time series are less homogenous.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 {{- /* ####### templates for console colors and formatting */ -}} {{- define \u0026#34;blue_bps\u0026#34; -}}{{ printf \u0026#34;\\033[1;34m%7sbps\\033[0m\u0026#34; . }}{{- end -}} {{- define \u0026#34;red\u0026#34; -}}{{ printf \u0026#34;\\033[1;31m%4s\\033[0m\u0026#34; . }}{{- end -}} {{- define \u0026#34;green\u0026#34; -}}{{ printf \u0026#34;\\033[1;32m%4s\\033[0m\u0026#34; . }}{{- end -}} {{- /* ####### query data from prometheus */ -}} {{- $state := printf \u0026#34;interface_state{hostname=\u0026#39;%s\u0026#39;}\u0026#34; .Params.hostname | query -}} {{- $in_samples := printf \u0026#34;interface_in_bps{hostname=\u0026#39;%s\u0026#39;}\u0026#34; .Params.hostname | query -}} {{- $out_samples := printf \u0026#34;interface_out_bps{hostname=\u0026#39;%s\u0026#39;}\u0026#34; .Params.hostname | query -}} {{- /* ####### print header */ -}} {{ print \u0026#34;STAT | IN BPS | OUT BPS | NAME | DESC\\n\u0026#34; }} {{- /* ####### for each returned interface... */ -}} {{- range $i, $iface := $state -}} {{- /* ####### write the first column as a string based on the value, in color */ -}} {{- if eq ($iface | value) 1.0 -}} {{ template \u0026#34;green\u0026#34; \u0026#34;UP\u0026#34; }} | {{- else if ($iface | value) 2.0 -}} {{ template \u0026#34;red\u0026#34; \u0026#34;DOWN\u0026#34; }} | {{- else -}} {{ template \u0026#34;red\u0026#34; \u0026#34;UNKN\u0026#34; }} | {{- end -}} {{- /* ####### write the in bps column */ -}} {{- template \u0026#34;blue_bps\u0026#34; index $in_samples $i | value | humanize -}} | {{- template \u0026#34;blue_bps\u0026#34; index $out_samples $i | value | humanize -}} | {{- printf \u0026#34; %24s\u0026#34; ($iface | label \u0026#34;name\u0026#34;) -}} | {{- $iface | label \u0026#34;description\u0026#34; }} {{ end -}} What to do with this? #I\u0026rsquo;m not sure yet. While I\u0026rsquo;ve dubbed above example show_int after the common router command (which lacks the current bits per second of course), it\u0026rsquo;s unclear where to go from here.\nUsing this interface for machine readable output does not seem wise, although one could in theory output the InfluxDB line protocol, for instance. However, InfluxDB can use Prometheus\u0026rsquo; remote read API endpoint directly.\n","date":"11 April 2020","permalink":"/posts/prometheus-consoles/","section":"Posts","summary":"An apparently little used feature in Prometheus is the ability to create\nso-called consoles or console templates. Even though Prometheus ships\nsome example consoles, this type of interface seems to be rarely used in\npractice.","title":"Prometheus Consoles and curl"},{"content":" Some general bla bla about the article. This is part of the summary presented in the post list. Inline Code here. There should be quite a bit of content so that the summary in the list view of posts does not include stranger things from down below. To his end, here some Lorem Ipsum: Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Links work too: Wikipedia.\nSome math for testing: $$ \\frac{n!}{k!(n-k)!} = \\binom{n}{k} $$\nA paragraph (with a footnote) #Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. That\u0026rsquo;s \u0026ldquo;some\u0026rdquo; text with a footnote.1\ngraph LR; A[Lemons]--\u003eB[Lemonade]; B--\u003eC[Profit] Quotes are nice:\nEverything we hear is an opinion, not a fact. Everything we see is a perspective, not the truth.\n\u0026mdash; not Marcus Aurelius, actually\nSome code with highlighted return lines:\n1 2 3 4 5 6 7 8 def __getattribute__(self, name): if name == \u0026#39;insert\u0026#39; and self.__root: return object.__getattribute__(self, name) elif name == \u0026#39;insert\u0026#39; and not self.__root: print(\u0026#34;This is not a root node.\u0026#34;) raise AttributeError else: return object.__getattribute__(self, name) run on playground Second level header, the other is reserved for the top spot #A list, but first some general bla bla to get some kind of paragraph going in this place. If it looks to empty, the following list will just hang around in place, looking weird:\nbla bla blah Don\u0026rsquo;t forget to follow me on Twitter. Third level header (I\u0026rsquo;ll never use fourth\u0026hellip;) #Lorem ipsum dolor sit amet consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet:\nbla bla blah And finally, a todo list:\ncheck all features make mathjax and fonts load locally profit?? Tables, whoo hoo # Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa Thats it, looking good? # \u0026ldquo;Some\u0026rdquo;, because I wanted to test the quotation marks.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"24 March 2020","permalink":"/posts/markdown/","section":"Posts","summary":"Some general bla bla about the article. This is part of the summary presented in the post list. Inline Code here. There should be quite a bit of content so that the summary in the list view of posts does not include stranger things from down below.","title":"All the Markdown Features I'm ever likely to use"},{"content":"","date":null,"permalink":"/tags/latex/","section":"Tags","summary":"","title":"Latex"},{"content":"","date":null,"permalink":"/tags/markdown/","section":"Tags","summary":"","title":"Markdown"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]